1.slint-plugin-react-hooks 限制语法（保证安全）

（渲染期间执行的）useMemo(()=>{可以返回内部计算结果},[]) ,针对参数的使用，判断参数的变化执行函数    [一般是有参数的，空数组只执行一次](参数是可以用 count===3类似这样)count从0开始，前三次是不执行计算的当cout=3时计算，内部时可以计算返回结果的，输出可以保存
memo针对函数组件的更新


本身的props没有变化但是父节点变化了，子节点内部函数都执行了，函数的执行可能和参数挂钩。只有参数变化才去执行

（渲染后执行的，执行的是副作用）useEffect 是在render后执行
可以替代componentDidMount,componentDidUpdate,
返回函数可以使componentwillunMount


const Context(随意参数)=createContext(初始值);
类组件中Context.Provider ,Context.Consumer内部函数获取参数
或者使用静态方法static contextType=Context; 内部通过const value=this.context;取值

useContext 对应于类组件中的
useContext(Context)取值


当useMemo返回的时函数时可以改写为useCallback
useCallback(fn)==useMemo(()=>fn)


useRef   Hooks
1.获取子组件或者dom节点的句柄
2.渲染周期间共享数据的存储
不能用来获取函数组件

    useEffect(() => {
       it=setInterval(()=>{
            setCount(count=>count+1)
        },1000)
    }, []);
需要清除it但是存储state里浪费；无法清楚



const double = useMemo(() => {
    return count * 2;
}, [count === 3])
double执行两次 是根据参数的变化来执行的 count === 3 false=>true  ,然后true=>false

[自定义hook来完善状态复用]



